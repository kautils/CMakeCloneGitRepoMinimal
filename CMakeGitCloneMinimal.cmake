if(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeKautilHeader.v0.0.cmake)
    file(DOWNLOAD https://raw.githubusercontent.com/kautils/CMakeKautilHeader/v0.0/CMakeKautilHeader.cmake ${CMAKE_BINARY_DIR}/CMakeKautilHeader.v0.0.cmake)
endif()
include(${CMAKE_BINARY_DIR}/CMakeKautilHeader.cmake)


macro(CMakeGitCloneMinimal prfx)
    
    set(CMakeGitCloneMinimal_evacu_m ${m})
    set(m CMakeGitCloneMinimal)
    
    if(NOT DEFINED KAUTIL_THIRD_PARTY_DIR)
        set(${m}_kautil_cmake_dest ${CMAKE_CURRENT_BINARY_DIR}/kautil_cmake)
        file(MAKE_DIRECTORY "${KAUTIL_THIRD_PARTY_DIR}")
    else()
        set(${m}_kautil_cmake_dest ${CMAKE_BINARY_DIR}/kautil_cmake)
    endif()

    git_clone(https://raw.githubusercontent.com/kautils/CMakeExecuteCommand/v0.0.1/CMakeExecuteCommand.cmake)
    
    cmake_parse_arguments( ${prfx} "CLEAR;FORCE_UPDATE;VERBOSE" "TAG;BRANCH;HASH;REPOSITORY_URI;REPOSITORY_REMOTE;DESTINATION" "" ${ARGV})
    set(${m}_prfx_unsetter)
    set(${m}_unsetter)
    list(APPEND ${m}_prfx_unsetter unsetter;CLEAR;FORCE_UPDATE;VERBOSE;VERBOSE_GIT;TAG;BRANCH;HASH;REPOSITORY_URI;REPOSITORY_REMOTE;DESTINATION)
    
    list(APPEND ${m}_unsetter ${m}_repo_tag ${m}_repo_branch ${m}_repo_digest)
    set(${m}_repo_tag ${${prfx}_TAG})
    set(${m}_repo_branch ${${prfx}_BRANCH})
    set(${m}_repo_digest ${${prfx}_HASH})

    list(APPEND ${m}_unsetter ${m}_repo_uri ${m}_repo_remote ${m}_repo_name ${m}_repo_force_update)
    set(${m}_repo_uri ${${prfx}_REPOSITORY_URI})
    set(${m}_repo_remote ${${prfx}_REPOSITORY_REMOTE})
    if(NOT DEFINED ${m}_repo_remote)
        set(${m}_repo_remote origin)
    endif()
    
    get_filename_component(${m}_repo_name ${${prfx}_REPOSITORY_URI} NAME)
    set(${m}_repo_force_update ${${prfx}_FORCE_UPDATE})
    
    
    list(APPEND ${m}_unsetter ${m}_result_var)
    set(${m}_result_var ${prfx})
    
    list(APPEND ${m}_unsetter ${m}_dest ${m}_dest_p ${m}_dest_c)
    set(${m}_dest ${${prfx}_DESTINATION})
    set(${m}_dest_p ${${m}_dest}/${${m}_repo_name})
    set(${m}_dest_c ${${m}_dest_p}/${${m}_repo_name})
    
    list(APPEND ${m}_unsetter ${m}_repo_tag ${m}_repo_branch ${m}_repo_digest)
    set(${m}_repo_tag ${${prfx}_TAG})
    set(${m}_repo_branch ${${prfx}_BRANCH})
    set(${m}_repo_digest ${${prfx}_HASH})
    
    if(${${prfx}_VERBOSE})
        include(CMakePrintHelpers)
        foreach(${m}_var ${${m}_unsetter})
            cmake_print_variables(${${m}_var})
        endforeach()
        unset(${m}_var)
    endif()
    
    list(APPEND ${m}_unsetter ${m}_verbose_option)
    if(${${prfx}_VERBOSE})
        set(${m}_verbose_option VERBOSE)
    endif()
    
    if((NOT DEFINED ${m}_repo_tag) AND ((NOT DEFINED ${m}_repo_branch) AND (NOT DEFINED ${m}_repo_digest)))
        message(FATAL_ERROR "must specify id to clone via HASH or TAG or BRANCH.")
    elseif( (DEFINED ${m}_repo_tag) AND ((DEFINED ${m}_repo_branch) OR (DEFINED ${m}_repo_digest)))
        message(FATAL_ERROR "only one id can be selected in HASH or TAG or BRANCH.")
    elseif( (DEFINED ${m}_repo_branch) AND ((DEFINED ${m}_repo_tag) OR (DEFINED ${m}_repo_digest)))
        message(FATAL_ERROR "only one id can be selected in HASH or TAG or BRANCH.")
    elseif( (DEFINED ${m}_repo_digest) AND ((DEFINED ${m}_repo_tag) OR (DEFINED ${m}_repo_branch)))
        message(FATAL_ERROR "only one id can be selected in HASH or TAG or BRANCH.")
    endif()
    
    if(DEFINED ${m}_repo_tag)
        set(${m}_cache_var ${${m}_dest_p}/${${m}_repo_tag})
    elseif(DEFINED ${m}_repo_branch)
        set(${m}_cache_var ${${m}_dest_p}/${${m}_repo_branch})
    elseif(DEFINED ${m}_repo_digest)
        set(${m}_cache_var ${${m}_dest_p}/${${m}_repo_digest})
    endif()
    
    
    if(${${m}_repo_force_update} 
            OR (NOT DEFINED CACHE{${${m}_cache_var}}) 
            OR (DEFINED CACHE{${${m}_cache_var}} AND NOT EXISTS ${${${m}_cache_var}}/.git))
        
        file(MAKE_DIRECTORY ${${m}_dest_c})
        CMakeExecuteCommand(execgit COMMAND git init DIR ${${m}_dest_c} ${${m}_verbose_option} ASSERT)
        CMakeExecuteCommand(execgit COMMAND git remote add origin ${${m}_repo_uri} DIR ${${m}_dest_c} ${${m}_verbose_option})
        
        if(DEFINED ${m}_repo_tag)
            CMakeExecuteCommand(execgit COMMAND git fetch ${${m}_repo_remote} --tags ${${m}_repo_tag} --depth=1 DIR ${${m}_dest_c} ${${m}_verbose_option} ASSERT)
            CMakeExecuteCommand(execgit COMMAND git checkout tags/${${m}_repo_tag} DIR ${${m}_dest_c} ${${m}_verbose_option} ASSERT)
            CMakeExecuteCommand(execgit COMMAND git rev-list -n 1 ${${m}_repo_tag} DIR ${${m}_dest_c} ${${m}_verbose_option} ASSERT)
            set(${m}_want_hash ${execgit_OUTPUT_VARIABLE})
        elseif(DEFINED ${m}_repo_branch)
            CMakeExecuteCommand(execgit COMMAND git fetch ${${m}_repo_remote} ${${m}_repo_branch} DIR ${${m}_dest_c} ${${m}_verbose_option} ASSERT)
            CMakeExecuteCommand(execgit COMMAND git checkout ${${m}_repo_branch} DIR ${${m}_dest_c} ${${m}_verbose_option} ASSERT)
            CMakeExecuteCommand(execgit COMMAND git rev-list -n 1 ${${m}_repo_branch} DIR ${${m}_dest_c} ${${m}_verbose_option} ASSERT)
            set(${m}_want_hash ${execgit_OUTPUT_VARIABLE})
        elseif(DEFINED ${m}_repo_digest)
            CMakeExecuteCommand(execgit COMMAND git fetch ${${m}_repo_remote} ${${m}_repo_digest} DIR ${${m}_dest_c} ${${m}_verbose_option} ASSERT)
            CMakeExecuteCommand(execgit COMMAND git checkout ${${m}_repo_digest} DIR ${${m}_dest_c} ${${m}_verbose_option} ASSERT)
            set(${m}_want_hash ${${m}_repo_digest})
        endif()
        
        if(DEFINED execgit_RESULT_VARIABLE AND (0 EQUAL ${execgit_RESULT_VARIABLE}))
            string(SUBSTRING ${${m}_want_hash} 0 7 ${m}_want_hash)
            unset(${${m}_cache_var} CACHE)
            set(${${m}_result_var} ${${m}_dest_p}/${${m}_want_hash} )
            set(${${m}_cache_var} ${${m}_dest_p}/${${m}_want_hash}  CACHE STRING "used by CMakeGitCloneMinimal internally (destination/full_id). generated by ${CMAKE_CURRENT_LIST_DIR}")
            if(EXISTS ${${${m}_result_var}})
                file(REMOVE_RECURSE ${${${m}_result_var}})
            endif()
            file(RENAME ${${m}_dest_c} ${${${m}_result_var}})
        endif()
        CMakeExecuteCommand(execgit CLEAR)
    else()
        set(${${m}_result_var} ${${${m}_cache_var}})
    endif()
    
    foreach(__var ${${m}_unsetter})
        unset(${__var})
    endforeach()
    foreach(__var ${${m}_prfx_unsetter})
        unset(${prfx}_${__var})
    endforeach()
    unset(__var)
    
    unset(${prfx}_UNPARSED_ARGUMENTS)
    unset(${m}_unsetter)
    unset(${m}_prfx_unsetter)
    set(m ${CMakeGitCloneMinimal_evacu_m})
    
endmacro()
